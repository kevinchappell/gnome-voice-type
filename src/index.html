<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Freezing Effect</title>
  <style>
    body {
      margin: 0;
      height: 200vh; /* for scroll demo */
      background: linear-gradient(#1e1e2f, #3a3a6a);
      color: white;
      font-family: sans-serif;
      overflow-x: hidden;
    }
    #frostCanvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 9999;
    }
    main {
      padding: 3rem;
    }
  </style>
</head>
<body>
  <main>
    <h1>Freezing Effect Demo</h1>
    <p>Scroll around and watch the page slowly "freeze" from the bottom up.</p>
  </main>
  <canvas id="frostCanvas"></canvas>
  
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js';

    const canvas = document.getElementById("frostCanvas");
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    const uniforms = {
      u_time: { value: 0.0 },
      u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      u_progress: { value: 0.0 }
    };

    const material = new THREE.ShaderMaterial({
      transparent: true,
      uniforms,
      fragmentShader: `
        precision highp float;

        uniform float u_time;
        uniform vec2 u_resolution;
        uniform float u_progress;

        // Noise function
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i+vec2(1.0,0.0));
          float c = hash(i+vec2(0.0,1.0));
          float d = hash(i+vec2(1.0,1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a, b, u.x) +
                 (c - a)* u.y * (1.0 - u.x) +
                 (d - b) * u.x * u.y;
        }

        void main() {
          vec2 uv = gl_FragCoord.xy / u_resolution.xy;
          
          // Freeze progresses upward
          float threshold = u_progress * (1.0 + 0.1*sin(u_time*0.5));
          float mask = smoothstep(threshold - 0.02, threshold, uv.y);

          // Ice crystal look with animated noise
          float n = noise(uv * 20.0 + u_time * 0.05);
          float frost = smoothstep(0.4, 0.8, n);

          vec3 frostColor = mix(vec3(0.0), vec3(0.7,0.9,1.0), frost);
          float alpha = mask * frost * 0.9;

          gl_FragColor = vec4(frostColor, alpha);
        }
      `
    });

    const geometry = new THREE.PlaneGeometry(2, 2);
    const quad = new THREE.Mesh(geometry, material);
    scene.add(quad);

    function animate(t) {
      uniforms.u_time.value = t * 0.001;
      uniforms.u_progress.value = Math.min(1.0, uniforms.u_time.value * 0.05); // grows upward over time
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate(0);

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
